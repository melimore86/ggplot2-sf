---
title: "Drawing beautiful maps programmatically with R, sf and ggplot2 — Part 1: Layouts"
author: "Mel Moreno and Mathieu Basille"
output:
  html_document:
    fig_caption: no
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(
    message = FALSE,
    warning = FALSE,
    cache = TRUE,
    tidy = FALSE,
    fig.width = 7,
    fig.height = 7,
    out.width = "65%"
)
## This is just to "pre-load" all packages, and prevent the startup
## messages to show
## Tutorial #1
library("ggplot2")
library("sf")
library("rworldmap")
library("rworldxtra")
library("ggspatial")
## Tutorial #2
library("maps")
library("tools")
library("ggmap")
library("ggrepel")
## Tutorial #3
library("grid")
library("cowplot")
```


# Beautiful maps in a beautiful world

Maps are used in a variety of fields to express data in an appealing and interpretive way. Data can be expressed into simplified patterns,  and this data interpretation is generally lost if the data is only seen through a spread sheet. Maps can add vital context by incorporating many variables into an easy to read and applicable context. Maps are also very important in the information world because they can quickly allow the public to gain better insight so that they can stay informed. It's critical to have maps be effective, which means creating maps that can be easily understood by a given audience. For instance, maps that need to be understood by children would be very different from maps intended to be shown to geographers. 

Knowing what elements are required to enhance your data is key into making effective maps. Basic elements of a map that should be considered are polygon, points, lines, and text. Polygons, on a map, are closed shapes such as country borders. Lines are considered to be linear shapes that are not filled with any aspect, such as highways, streams, or roads. Finally, points are used to specify specific positions, such as city or landmark locations. With that in mind, one need to think about what elements are required in the map to really make an impact, and convey the information for the intended audience.Layout and formatting are the second critical aspect to enhance data visually. The arrangement of these map elements and how they will be drawn can be adjusted to make a maximum impact.


## A solution using R and its ecosystem of packages

Current solutions for creating maps usually involves GIS software, such as ArcGIS, QGIS, eSpatial, etc., which allow to visually prepare a map, in the same approach as one would prepare a poster or a document layout. On the other hand, R, a free and open-source software development environment (IDE) that is used for computing statistical data and graphic in a programmable language, has developed advanced spatial capabilities over the years, and can be used to draw maps programmatically.

R is a powerful and flexible tool. R can be used from calculating data sets to creating graphs and maps with the same data set. R is also free, which makes it easily accessible to anyone. Some other advantages of using R is that it has an interactive language, data structures, graphics availability, a developed community, and the advantage of adding more functionalities through an entire ecosystem of packages. R is a scriptable language that allows the user to write out a code in which it will execute the commands specified.

Using R to create maps brings these benefits to mapping. Elements of a map can be added or removed with ease — R code can be tweaked to make major enhancements with a stroke of a key. It is also easy to reproduce the same maps for different data sets. It is important to be able to script the elements of a map, so that it can be re-used and interpreted by any user. In essence, comparing typical GIS software and R for drawing maps is similar to comparing word processing software (e.g. Microsoft Office or LibreOffice) and a programmatic typesetting system such as LaTeX, in that typical GIS software implement a WYSIWIG approach ("What You See Is What You Get"), while R implements a WYSIWYM approach ("What You See Is What You Mean").

The package `ggplot2` implements the grammar of graphics in R, as a way to create code that make sense to the user: The grammar of graphics is a term used to breaks up graphs into semantic components, such as geometries and layers. Practically speaking, it allows (and forces!) the user to focus on graph elements at a higher level of abstraction, and how the data must be structured to achieve the expected outcome. While `ggplot2` is becoming the de facto standard for R graphs, it does not handle spatial data specifically. The current state-of-the-art of spatial objects in R relies on `Spatial` classes defined in the package [`sp`](https://cran.r-project.org/package=sp), but the new package [`sf`](https://cran.r-project.org/package=sf) has recently implemented the "simple feature" standard, and is steadily taking over `sp`. Recently, the package `ggplot2` has allowed the use of simple features from the package `sf` as layers in a graph[^ggplotsf]. The combination of `ggplot2` and `sf` therefore enables to programmatically create maps, using the grammar of graphics, just as informative or visually appealing as traditional GIS software.

[^ggplotsf]: Note: Support of `sf` objects is only available since the version 3.0.0 of `ggplot2`, recently released on CRAN.


## A tutorial to draw beautiful maps programmatically with R, sf and ggplot2

This tutorial is the third part in a series of three:

* General concepts illustrated with the world map
* Adding additional layers: an example with points and polygons
* Positioning and layout for complex maps

After the presentation of the basic map concepts, and the flexible approach in layer implemented in `ggplot2`, this section will illustrate how to achieve complex layouts, for instance with map insets, or several maps combined. Depending on the visual information that needs to be displayed, maps and their corresponding data might need to be arranged to create easy to read graphical representations. This tutorial will provide different approaches to arranges maps in the plot, in order to make the information portrayed more aesthetically appealing, and most importantly, convey the information better.


## Getting started

Many R packages are available from [CRAN](https://cran.r-project.org/), the Comprehensive R Archive Network, which is the primary repository of R packages. The full list of packages necessary for this series of tutorials can be installed with:

```{r pkg-install-all, eval = FALSE}
install.packages(c("cowplot", "ggmap", "ggplot2", "ggrepel", 
    "ggspatial", "libwgeom", "sf", "rworldmap", "rworldxtra"))
```

We start by loading the basic packages necessary for all maps, i.e. `ggplot2` and `sf`. We also suggest to use the classic dark-on-light theme for `ggplot2` (`theme_bw`), which is more appropriate for maps:

```{r pkg-ggplot2-sf}
library("ggplot2")
theme_set(theme_bw())
library("sf")
```

The package `rworldmap` provides a map of countries of the entire world; a map with higher resolution is available in the package `rworldxtra`. We use the function `getMap` to extract the world map (the resolution can be set to `"low"`, if preferred):

```{r pkg-rworldmap}
library("rworldmap")
library("rworldxtra")
world <- getMap(resolution = "high")
class(world)
```

The world map is available as a `SpatialPolygonsDataFrame` from the package `sp`; we thus convert it to a simple feature using `st_as_sf` from package `sf`:

```{r world-sf}
world <- st_as_sf(world)
class(world)
```


# General concepts

2 solutions:

* Grobs (graphic objects, allow plots only in plot region, based on coordinates): directly using `ggplot2`
* `ggdraw` (allows plots anywhere, including outer margins, based on relative position): package `cowplot`

Example illustrating the difference between the two, and their use:

```{r inset-example-qplot}
(g1  <- qplot(0:10, 0:10))
```

```{r inset-example-qplot-void, fig.width = 3, fig.height = 3, out.width = "35%"}
(g1_void <- g1 + theme_void() + theme(panel.border = element_rect(colour = "black", 
    fill = NA)))
```

Graphs from `ggplot2` can be saved, like any other R object. They can then be reused later in other functions.

Using grobs, and `annotation_custom`:

```{r inset-example-grobs}
g1 +
    annotation_custom(
        grob = ggplotGrob(g1_void),
        xmin = 0,
        xmax = 3,
        ymin = 5,
        ymax = 10
    ) +
    annotation_custom(
        grob = ggplotGrob(g1_void),
        xmin = 5,
        xmax = 10,
        ymin = 0,
        ymax = 3
    )
```

Using `ggdraw` (note: used to build on top of initial plot; could be left empty to arrange subplots on a grid; plots are "filled" with their plots, unless the plot itself has a constrained ratio, like a map):

```{r inset-example-ggdraw}
ggdraw(g1) +
    draw_plot(g1_void, width = 0.25, height = 0.5, x = 0.02, y = 0.48) +
    draw_plot(g1_void, width = 0.5, height = 0.25, x = 0.75, y = 0.09)
```


# Several maps side by side or on a grid
 
Having a way show in a visualization, a specific area can be very useful. Many scientists usually create maps for each specific area manually. This is fine, but there are simpler ways to display what is needed for a report, or publication. 

This exmaple is using two maps side by side, including the legend of the first one. It illustrates how to use a custom grid, which can be made a lot more complex with different elements.

First simplify `REGION` for the legend:

```{r grid-region}
levels(world$REGION)[7] <- "South America"
```

Prepare the subplots, #1 world:

```{r grid-world, fig.width = 12, fig.height = 5, out.width = "90%"}
(gworld <- ggplot(data = world) +
     geom_sf(aes(fill = REGION)) +
     geom_rect(xmin = -102.15, xmax = -74.12, ymin = 7.65, ymax = 33.97, 
         fill = NA, colour = "black", size = 1.5) +
     scale_fill_viridis_d(option = "plasma") +
     theme(panel.background = element_rect(fill = "azure"),
         panel.border = element_rect(fill = NA)))
```

And #2 Gulf:

```{r grid-gulf}
(ggulf <- ggplot(data = world) +
     geom_sf(aes(fill = REGION)) +
     annotate(geom = "text", x = -90, y = 26, label = "Gulf of Mexico", 
         fontface = "italic", color = "grey22", size = 6) +
     coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97), expand = FALSE) +
     scale_fill_viridis_d(option = "plasma") +
     theme(legend.position = "none", axis.title.x = element_blank(), 
         axis.title.y = element_blank(), panel.background = element_rect(fill = "azure"), 
         panel.border = element_rect(fill = NA)))
```

Final map using ggplot only (explain trick with empty ggplot first, constrained by `coord_equal` to give delineations of the plot region, where to add the grobs):

```{r grid-grobs, fig.width = 15, fig.height = 5, out.width = "90%"} 
ggplot() +
    coord_equal(xlim = c(0, 3.3), ylim = c(0, 1), expand = FALSE) +
    annotation_custom(ggplotGrob(gworld), xmin = 0, xmax = 2.3, ymin = 0, 
        ymax = 1) +
    annotation_custom(ggplotGrob(ggulf), xmin = 2.3, xmax = 3.3, ymin = 0, 
        ymax = 1) +
    theme_void()
```

Final plot using `plot_grid` (`cowplot`): explain the grid (nrow, ncol, rel_widths, etc.)

```{r grid-plot-grid, fig.width = 15, fig.height = 5, out.width = "90%"}
library("cowplot")
theme_set(theme_bw())

plot_grid(gworld, ggulf, nrow = 1, rel_widths = c(2.3, 1))
```

Using `plot_grid(cowplot)` to arrange `ggplot` figures, is versatile. Any `ggplot` figure can be arranged just like the figure above. There are many commands that allow for the plot to have different placements, such as `nrow=1` means that the figure will only occpuy one row and muitple columns, and `ncol=1` means the figure will be plotted on one column and multplie rows. Some other commands can adjust the position of the figures such as adding `align=v` to align vertically on the left axis, and `align=h` to align horiztonally. 

Note also the existence of `get_legend` (`cowplot`), and that the legend can be used as any object.

`ggsave` OK to be used here.
 
```{r, eval = FALSE}
ggsave("grid.pdf", width = 15, height =  5)
```

---

# Map insets

<!-- Text of the section to rework entirely. I left your text below the new example. -->

For map insets directly on the background map, both solutions are viable (and one might prefer one or the other depending on relative or absolute coordinates).

Map example using map of the 50 states of the US, including Alaska and Hawaii (note: not to scale for the latter), using reference projections for US maps. First map (continental states) use a 10/6 figure:

```{r inset-usa, fig.width = 10, fig.height = 6, out.width = "90%"}
usa <- subset(world, ADMIN == "United States of America")
## US National Atlas Equal Area (2163)
## http://spatialreference.org/ref/epsg/us-national-atlas-equal-area/
(mainland <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(2163), xlim = c(-2500000, 2500000), ylim = c(-2300000, 
         730000)))
```

Alaska (note: `datum = NA` removes graticules and coordinates):

```{r inset-alaska, fig.width = 10, fig.height = 6}
## Alaska: NAD83(NSRS2007) / Alaska Albers (3467)
## http://www.spatialreference.org/ref/epsg/3467/
(alaska <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(3467), xlim = c(-2400000, 1600000), ylim = c(200000, 
         2500000), expand = FALSE, datum = NA))
```

Hawaii:

```{r inset-hawaii, fig.width = 10, fig.height = 7}
## Hawaii: Old Hawaiian (4135)
## http://www.spatialreference.org/ref/epsg/4135/
(hawaii  <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(4135), xlim = c(-161, -154), ylim = c(18, 
         23), expand = FALSE, datum = NA))
```

Using `ggdraw` from `cowplot` (tricky to define exact positions; note the use of the ratios of the inset, combined with the ratio of the plot):

```{r inset-ggdraw, fig.width = 10, fig.height = 6, out.width = "90%"}
(ratioAlaska <- (2500000 - 200000) / (1600000 - (-2400000)))
(ratioHawaii  <- (23 - 18) / (-154 - (-161)))

ggdraw(mainland) +
    draw_plot(alaska, width = 0.26, height = 0.26 * 10/6 * ratioAlaska, 
        x = 0.05, y = 0.05) +
    draw_plot(hawaii, width = 0.15, height = 0.15 * 10/6 * ratioHawaii, 
        x = 0.3, y = 0.05)
```

`ggsave` OK:

```{r inset-ggdraw-save, eval = FALSE}
ggsave("map-us-ggdraw.pdf", width = 10, height = 6)
```

Same using grobs (note the use of xdiff/ydiff and arbitrary ratios):

```{r inset-grobs, fig.width = 10, fig.height = 6, out.width = "90%"}
mainland +
    annotation_custom(
        grob = ggplotGrob(alaska),
        xmin = -2750000,
        xmax = -2750000 + (1600000 - (-2400000))/2.5,
        ymin = -2450000,
        ymax = -2450000 + (2500000 - 200000)/2.5
    ) +
    annotation_custom(
        grob = ggplotGrob(hawaii),
        xmin = -1250000,
        xmax = -1250000 + (-154 - (-161))*120000,
        ymin = -2450000,
        ymax = -2450000 + (23 - 18)*120000
    )
```

Save OK with `ggsave`:

```{r inset-grobs-save, eval = FALSE}
ggsave("map-inset-grobs.pdf", width = 10, height = 6)
```


---

The `print` command can be used place multiple maps in one map graphic. Essentially the `print` command <!-- end of sentence missing! -->
This can be a useful and easy way to enhance the information you need to display.  

```{r print_mapsdata, include=FALSE}
## rmarkplot <- ggplot(data = world) +
##     geom_sf(fill = "antiquewhite1") +
##     annotate(geom = "text", x = -85.5, y = 27.5, label = "Gulf of Mexico", 
##         color = "grey22", size = 4.5) +
##     coord_sf(xlim = c(-87.35, -79.5), ylim = c(24.1, 30.8), expand = TRUE) +
##     xlab("Longitude")+ ylab("Latitude") +
##     theme_classic() + 
##     theme(legend.position = "none", panel.grid.major = element_line(colour = gray(0.5), 
##         linetype = "dashed", size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
##         panel.border = element_rect(fill = NA))

## library("ggthemes")
## rmarkplot2 <- ggplot(data = world) + 
##   geom_sf(fill="antiquewhite1") +
##   coord_sf(xlim = c(-80.30, -80.00 ), ylim = c(26.63, 26.9), expand=TRUE ) +
##     ggtitle ("Location A") + 
##   xlab("Longitude")+ ylab("Latitude") +
##   theme_map() + 
##   theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA),text=element_text(size=6))

## rmarkplot3<- 
##   ggplot(data=world)+
##   geom_sf(fill="antiquewhite1") +
##   coord_sf(xlim = c(-80.30, -80.00 ), ylim = c(26.62, 26.35), expand=TRUE ) + 
##   ggtitle ("Location B") + 
##   xlab("Longitude")+ ylab("Latitude") +
##   theme_map() + 
##   theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA),text=element_text(size=6))
```

To specify where each plot is displayed with the  `print` function, the argument `viewport` needs to specify the maximum width and height of each map, and the minimum x and y coordinates of where the maps are located. The argument `just` will make a position on how the secondary maps will be displayed. All maps are the same size, until the sizes are adjusted with `width` and `height`.

```{r print_vp}
## vp <- viewport(width = 0.37, height = 0.32, x = 0.22, y =0.45, just = c("left","bottom")) 
## vp1<- viewport(width = 0.37, height = 0.32, x = 0.22, y =0.15, just = c("left","bottom")) 
```

Now the `print` function can be used the previous specifications that were listed in each plots' `viewport`. 

```{r print_finalmap}
## print(rmarkplot)
## print(rmarkplot2, vp=vp)
## print(rmarkplot3, vp=vp1)
```


# Several maps connected with arrows


Site coordinates, same as tuto #1:

```{r map-arrows-sites}
sites <- st_as_sf(data.frame(longitude = c(-80.15, -80.1), latitude = c(26.5, 
    26.8)), coords = c("longitude", "latitude"), crs = 4326, 
    agr = "constant")
```

Maps to be used finally: #1 Florida:

```{r map-arrows-florida}
(florida <- ggplot(data = world) +
     geom_sf(fill = "antiquewhite1") +
     geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
     annotate(geom = "text", x = -85.5, y = 27.5, label = "Gulf of Mexico", 
         color = "grey22", size = 4.5) +
     coord_sf(xlim = c(-87.35, -79.5), ylim = c(24.1, 30.8)) +
     xlab("Longitude")+ ylab("Latitude")+
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA)))
```

#2 Site A

```{r map-arrows-sitea, fig.width = 3, fig.height = 3, out.width = "35%"}
(siteA <- ggplot(data = world) +
     geom_sf(fill = "antiquewhite1") +
     geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
     coord_sf(xlim = c(-80.25, -79.95), ylim = c(26.65, 26.95), expand = FALSE) + 
     annotate("text", x = -80.18, y = 26.92, label= "Site A", size = 6) + 
     theme_void() + 
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA)))
```

#3 Site B

```{r map-arrows-siteb, fig.width = 3, fig.height = 3, out.width = "35%"}
(siteB <- ggplot(data = world) + 
     geom_sf(fill = "antiquewhite1") +
     geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
     coord_sf(xlim = c(-80.3, -80), ylim = c(26.35, 26.65), expand = FALSE) +
     annotate("text", x = -80.23, y = 26.62, label= "Site B", size = 6) + 
     theme_void() +
     theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
         size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
         panel.border = element_rect(fill = NA)))
```

Coordinates of the 2 arrows:

```{r map-arrows-arrows}
arrowA <- data.frame(x1 = 18.5, x2 = 23, y1 = 9.5, y2 = 14.5)
arrowB <- data.frame(x1 = 18.5, x2 = 23, y1 = 8.5, y2 = 6.5)
```

Final map (`ggplot` only):

```{r map-arrows-plot, fig.width = 10, fig.height = 7, out.width = "90%"}
ggplot() +
    coord_equal(xlim = c(0, 28), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(ggplotGrob(florida), xmin = 0, xmax = 20, ymin = 0, 
        ymax = 20) +
    annotation_custom(ggplotGrob(siteA), xmin = 20, xmax = 28, ymin = 11.25, 
        ymax = 19) +
    annotation_custom(ggplotGrob(siteB), xmin = 20, xmax = 28, ymin = 2.5, 
        ymax = 10.25) +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowA, 
        arrow = arrow(), lineend = "round") +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowB, 
        arrow = arrow(), lineend = "round") +
    theme_void()
```

`ggsave` works OK.

```{r, eval = FALSE}
ggsave("florida-sites.pdf", width = 10, height = 7)
```

`ggdraw` could also be used for a similar result:

```{r map-arrows-ggdraw, fig.width = 10, fig.height = 7, out.width = "90%"}
ggdraw(xlim = c(0, 28), ylim = c(0, 20)) +
    draw_plot(florida, x = 0, y = 0, width = 20, height = 20) +
    draw_plot(siteA, x = 20, y = 11.25, width = 8, height = 8) +
    draw_plot(siteB, x = 20, y = 2.5, width = 8, height = 8) +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowA, 
        arrow = arrow(), lineend = "round") +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowB, 
        arrow = arrow(), lineend = "round")
```



---

