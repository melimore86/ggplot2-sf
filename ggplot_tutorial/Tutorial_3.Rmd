---
title: "Drawing beautiful maps programmatically with R, sf and ggplot2 — Part 1: Layouts"
author: "Mel Moreno and Mathieu Basille"
output:
  html_document:
    fig_caption: no
    toc: yes
    toc_depth: 2
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    toc_depth: '2'
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(
    message = FALSE,
    warning = FALSE,
    cache = TRUE,
    tidy = FALSE,
    fig.width = 7,
    fig.height = 7,
    out.width = "65%"
)
## This is just to "pre-load" all packages, and prevent the startup
## messages to show
## Tutorial #1
library("ggplot2")
library("sf")
library("rworldmap")
library("rworldxtra")
library("ggspatial")
## Tutorial #2
library("maps")
library("tools")
library("ggmap")
library("ggrepel")
## Tutorial #3
library("grid")
```


# Beautiful maps in a beautiful world

Maps are used in a variety of fields to express data in an appealing and interpretive way. Data can be expressed into simplified patterns,  and this data interpretation is generally lost if the data is only seen through a spread sheet. Maps can add vital context by incorporating many variables into an easy to read and applicable context. Maps are also very important in the information world because they can quickly allow the public to gain better insight so that they can stay informed. It's critical to have maps be effective, which means creating maps that can be easily understood by a given audience. For instance, maps that need to be understood by children would be very different from maps intended to be shown to geographers. 

Knowing what elements are required to enhance your data is key into making effective maps. Basic elements of a map that should be considered are polygon, points, lines, and text. Polygons, on a map, are closed shapes such as country borders. Lines are considered to be linear shapes that are not filled with any aspect, such as highways, streams, or roads. Finally, points are used to specify specific positions, such as city or landmark locations. With that in mind, one need to think about what elements are required in the map to really make an impact, and convey the information for the intended audience.Layout and formatting are the second critical aspect to enhance data visually. The arrangement of these map elements and how they will be drawn can be adjusted to make a maximum impact.


## A solution using R and its ecosystem of packages

Current solutions for creating maps usually involves GIS software, such as ArcGIS, QGIS, eSpatial, etc., which allow to visually prepare a map, in the same approach as one would prepare a poster or a document layout. On the other hand, R, a free and open-source software development environment (IDE) that is used for computing statistical data and graphic in a programmable language, has developed advanced spatial capabilities over the years, and can be used to draw maps programmatically.

R is a powerful and flexible tool. R can be used from calculating data sets to creating graphs and maps with the same data set. R is also free, which makes it easily accessible to anyone. Some other advantages of using R is that it has an interactive language, data structures, graphics availability, a developed community, and the advantage of adding more functionalities through an entire ecosystem of packages. R is a scriptable language that allows the user to write out a code in which it will execute the commands specified.

Using R to create maps brings these benefits to mapping. Elements of a map can be added or removed with ease — R code can be tweaked to make major enhancements with a stroke of a key. It is also easy to reproduce the same maps for different data sets. It is important to be able to script the elements of a map, so that it can be re-used and interpreted by any user. In essence, comparing typical GIS software and R for drawing maps is similar to comparing word processing software (e.g. Microsoft Office or LibreOffice) and a programmatic typesetting system such as LaTeX, in that typical GIS software implement a WYSIWIG approach ("What You See Is What You Get"), while R implements a WYSIWYM approach ("What You See Is What You Mean").

The package `ggplot2` implements the grammar of graphics in R, as a way to create code that make sense to the user: The grammar of graphics is a term used to breaks up graphs into semantic components, such as geometries and layers. Practically speaking, it allows (and forces!) the user to focus on graph elements at a higher level of abstraction, and how the data must be structured to achieve the expected outcome. While `ggplot2` is becoming the de facto standard for R graphs, it does not handle spatial data specifically. The current state-of-the-art of spatial objects in R relies on `Spatial` classes defined in the package [`sp`](https://cran.r-project.org/package=sp), but the new package [`sf`](https://cran.r-project.org/package=sf) has recently implemented the "simple feature" standard, and is steadily taking over `sp`. Recently, the package `ggplot2` has allowed the use of simple features from the package `sf` as layers in a graph[^ggplotsf]. The combination of `ggplot2` and `sf` therefore enables to programmatically create maps, using the grammar of graphics, just as informative or visually appealing as traditional GIS software.

[^ggplotsf]: Note: Support of `sf` objects is only available since the version 3.0.0 of `ggplot2`, recently released on CRAN.


## A tutorial to draw beautiful maps programmatically with R, sf and ggplot2

This tutorial is the third part in a series of three:

* General concepts illustrated with the world map
* Adding additional layers: an example with points and polygons
* Positioning and layout for complex maps

After the presentation of the basic map concepts, and the flexible approach in layer implemented in `ggplot2`, this section will illustrate how to achieve complex layouts, for instance with map insets, or several maps combined. Depending on the visual information that needs to be displayed, maps and their corresponding data might need to be arranged to create easy to read graphical representations. This tutorial will provide different approaches to arranges maps in the plot, in order to make the information portrayed more aesthetically appealing, and most importantly, convey the information better.


## Getting started

Many R packages are available from [CRAN](https://cran.r-project.org/), the Comprehensive R Archive Network, which is the primary repository of R packages. The full list of packages necessary for this series of tutorials can be installed with:

```{r pkg-install-all, eval = FALSE}
install.packages(c("ggmap", "ggplot2", "ggrepel", "ggspatial", 
    "libwgeom", "sf", "rworldmap", "rworldxtra"))
```

We start by loading the basic packages necessary for all maps, i.e. `ggplot2` and `sf`. We also suggest to use the classic dark-on-light theme for `ggplot2` (`theme_bw`), which is more appropriate for maps:

```{r pkg-ggplot2-sf}
library("ggplot2")
theme_set(theme_bw())
library("sf")
```

The package `rworldmap` provides a map of countries of the entire world; a map with higher resolution is available in the package `rworldxtra`. We use the function `getMap` to extract the world map (the resolution can be set to `"low"`, if preferred):

```{r pkg-rworldmap}
library("rworldmap")
library("rworldxtra")
world <- getMap(resolution = "high")
class(world)
```

The world map is available as a `SpatialPolygonsDataFrame` from the package `sp`; we thus convert it to a simple feature using `st_as_sf` from package `sf`:

```{r world-sf}
world <- st_as_sf(world)
class(world)
```


# Map insets

<!-- Text of the section to rework entirely -->

The `print` command can be used place multiple maps in one map graphic. Essentially the `print` command <!-- end of sentence missing! -->
This can be a useful and easy way to enhance the information you need to display.  

```{r print_mapsdata, include=FALSE}
## rmarkplot <- ggplot(data = world) +
##     geom_sf(fill = "antiquewhite1") +
##     annotate(geom = "text", x = -85.5, y = 27.5, label = "Gulf of Mexico", 
##         color = "grey22", size = 4.5) +
##     coord_sf(xlim = c(-87.35, -79.5), ylim = c(24.1, 30.8), expand = TRUE) +
##     xlab("Longitude")+ ylab("Latitude") +
##     theme_classic() + 
##     theme(legend.position = "none", panel.grid.major = element_line(colour = gray(0.5), 
##         linetype = "dashed", size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
##         panel.border = element_rect(fill = NA))

## library("ggthemes")
## rmarkplot2 <- ggplot(data = world) + 
##   geom_sf(fill="antiquewhite1") +
##   coord_sf(xlim = c(-80.30, -80.00 ), ylim = c(26.63, 26.9), expand=TRUE ) +
##     ggtitle ("Location A") + 
##   xlab("Longitude")+ ylab("Latitude") +
##   theme_map() + 
##   theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA),text=element_text(size=6))

## rmarkplot3<- 
##   ggplot(data=world)+
##   geom_sf(fill="antiquewhite1") +
##   coord_sf(xlim = c(-80.30, -80.00 ), ylim = c(26.62, 26.35), expand=TRUE ) + 
##   ggtitle ("Location B") + 
##   xlab("Longitude")+ ylab("Latitude") +
##   theme_map() + 
##   theme(legend.position = "none", panel.grid.major = element_line(colour = gray(.5), linetype = "dashed", size = 0.5),panel.background = element_rect(fill = "aliceblue"), panel.border=element_rect(fill=NA),text=element_text(size=6))
```

To specify where each plot is displayed with the  `print` function, the argument `viewport` needs to specify the maximum width and height of each map, and the minimum x and y coordinates of where the maps are located. The argument `just` will make a position on how the secondary maps will be displayed. All maps are the same size, until the sizes are adjusted with `width` and `height`.

```{r print_vp}
## vp <- viewport(width = 0.37, height = 0.32, x = 0.22, y =0.45, just = c("left","bottom")) 
## vp1<- viewport(width = 0.37, height = 0.32, x = 0.22, y =0.15, just = c("left","bottom")) 
```

Now the `print` function can be used the previous specifications that were listed in each plots' `viewport`. 

```{r print_finalmap}
## print(rmarkplot)
## print(rmarkplot2, vp=vp)
## print(rmarkplot3, vp=vp1)
```


2 solutions:

* Viewports (allow plots anywhere, including outer margins, based on relative position): package `grid`
* Grobs (graphic objects, allow plots only in plot region, based on coordinates): directly using `ggplot2`

Example illustrating the difference between the two, and their use:

```{r inset-example-qplot}
g1  <- qplot(0:10, 0:10)
g1_void <- g1 + theme_void() + theme(panel.border = element_rect(colour = "black", fill=NA))
```

Graphs from `ggplot2` can be saved, in which case they are not print. Calling their name, or using `print` plots them, the latter allowing for more options:

```{r inset-example-print, out.width = "45%"}
print(g1)
print(g1_void)
```

Using viewports (note: initial viewport takes the entire plot, from 0 to 1 on both axes; viewports are "filled" with their plots, unless the plot itself has a constrained ratio, like a map):

```{r inset-example-viewports}
library("grid")
vp_topleft <- viewport(width = 0.25, height = 0.5, x = 0.02, y = 0.98, just = c("left", "top"))
vp_bottomright <- viewport(width = 0.5, height = 0.25, x = 1, y = 0.09, just = c("center", "bottom"))

print(g1)
print(g1_void, vp = vp_topleft)
print(g1_void, vp = vp_bottomright)
```

Using grobs, and `annotation_custom`:

```{r inset-example-grobs}
gg1 <- ggplotGrob(g1)
gg1_void  <- ggplotGrob(g1_void)

g1 +
    annotation_custom(
        grob = gg1_void,
        xmin = 0,
        xmax = 3,
        ymin = 5,
        ymax = 10
    ) +
    annotation_custom(
        grob = gg1_void,
        xmin = 5,
        xmax = 10,
        ymin = 0,
        ymax = 3
    )
```

Hence for map insets directly on the background map, both solutions are viable (and one might prefer one or the other depending on relative or absolute coordinates).

Map example using map of the 50 states of the US, including Alaska and Hawaii (note: not to scale for the latter), using reference projections for US maps:

```{r inset-usa}
usa <- subset(world, ADMIN == "United States of America")
## US National Atlas Equal Area (2163)
## http://spatialreference.org/ref/epsg/us-national-atlas-equal-area/
(mainland <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(2163), xlim = c(-2500000, 2500000), ylim = c(-2300000, 
         730000)))
```

Alaska (note: `datum = NA` removes graticules and coordinates):

```{r inset-alaska}
## Alaska: NAD83(NSRS2007) / Alaska Albers (3467)
## http://www.spatialreference.org/ref/epsg/3467/
(alaska <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(3467), xlim = c(-2400000, 1600000), ylim = c(200000, 
         2500000), expand = FALSE, datum = NA))
```

Hawaii:

```{r inset-hawaii}
## Hawaii: Old Hawaiian (4135)
## http://www.spatialreference.org/ref/epsg/4135/
(hawaii  <- ggplot(data = usa) +
     geom_sf(fill = "cornsilk") +
     coord_sf(crs = st_crs(4135), xlim = c(-161, -154), ylim = c(18, 
         23), expand = FALSE, datum = NA))
```

Using viewports (tricky to define exact positions; note the use of the ratios of the inset, combined with the ratio of the plot):

```{r inset-viewports, fig.width = 10, fig.height = 6, out.width = "90%"}
xdiffAlaska <- 1600000 - (-2400000)
ydiffAlaska <- 2500000 - 200000
(ratioAlaska <- ydiffAlaska / xdiffAlaska)
vp_alaska <- viewport(width = 0.26, height = 0.26*10/6*ratioAlaska, x = 0.05, y = 0.05, just = c("left", "bottom"))

xdiffHawaii <- -154 - (-161)
ydiffHawaii  <- 23 - 18
(ratioHawaii  <- ydiffHawaii / xdiffHawaii)
vp_hawaii <- viewport(width = 0.15, height = 0.15*10/6*ratioHawaii, x = 0.3, y = 0.05, just = c("left", "bottom"))

print(mainland)
print(alaska, vp = vp_alaska)
print(hawaii, vp = vp_hawaii)
```

`ggsave` only takes last viewport; solution with specific device (`png`, `pdf`, …)

```{r inset-viewports-save, eval = FALSE}
png(filename = "map-us-viewports.png", width = 10, height = 6, units = "in", res = 300)
print(mainland)
print(alaska, vp = vp_alaska)
print(hawaii, vp = vp_hawaii)
dev.off()
```

Same using grobs (note the use of xdiff/ydiff and arbitrary ratios):

```{r inset-grobs, fig.width = 10, fig.height = 6, out.width = "90%"}
mainland +
    annotation_custom(
        grob = ggplotGrob(alaska),
        xmin = -2750000,
        xmax = -2750000 + xdiffAlaska/2.5,
        ymin = -2450000,
        ymax = -2450000 + ydiffAlaska/2.5
    ) +
    annotation_custom(
        grob = ggplotGrob(hawaii),
        xmin = -1250000,
        xmax = -1250000 + xdiffHawaii*120000,
        ymin = -2450000,
        ymax = -2450000 + ydiffHawaii*120000
    )
```

Save OK with `ggsave`:

```{r inset-grobs-save, eval = FALSE}
ggsave("map-inset-grobs.pdf")
```


# Several maps side by side or on a grid

<!-- Text of the section to rework entirely -->

****************



# Several maps connected with arrows

<!-- Text of the section to rework entirely -->

Having a way to emphasize locations on a map can also be a graphic that would be useful for biologists. The next steps will be to create blank sqaure plots that will make the map visualization interesting and accurate. In the following map, arrows will point to specific locations.

First we will start with the overall packages needed to build this 

Credit to Ilya Kashnitsky (https://ikashnitsky.github.io/2017/align-six-maps/).

```{r listplot_packages, eval=FALSE}
## library(sp)
## library(sf)
## library(ggplot2)
## library(cowplot)
## library(ggthemes)
## library(gridExtra)
## library(grid)
## library(lattice)
## library(tidyverse)
```


## Map Placement Function 

The function below will allow us to grab plots that we have previously made, with `ggplotGrob` , and create arrows pointing to the maps. 

The `list.plots`, is a simple list command to combine all of the previously created plots.

Afterwards, a function is created to create a custom annotation of each plot, with their corresponding x-min and x-max coordinates. From the bottom left corner of the image, it would be considered 0,0 if it was compared to a mathematical graph. 

The `df.arrows` has the beginning and ending locations of each line. If this case, there are two lines, but more lines can be created by adding more starting locations for `x=` and `y=`. 



```{r map-arrows-sites}
sites <- st_as_sf(data.frame(longitude = c(-80.15, -80.1), latitude = c(26.5, 
    26.8)), coords = c("longitude", "latitude"), crs = 4326, 
    agr = "constant")
```


```{r map-arrows-maps}
florida <- ggplot(data = world) +
    geom_sf(fill = "antiquewhite1") +
    geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
    annotate(geom = "text", x = -85.5, y = 27.5, label = "Gulf of Mexico", 
        color = "grey22", size = 4.5) +
    coord_sf(xlim = c(-87.35, -79.5), ylim = c(24.1, 30.8)) +
    xlab("Longitude")+ ylab("Latitude")+
    theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
        size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
        panel.border = element_rect(fill = NA))

siteA <- ggplot(data = world) +
    geom_sf(fill = "antiquewhite1") +
    geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
    coord_sf(xlim = c(-80.25, -79.95), ylim = c(26.65, 26.95), expand = FALSE) + 
    annotate("text", x = -80.18, y = 26.92, label= "Site A", size = 6) + 
    theme_void() + 
    theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
        size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
        panel.border = element_rect(fill = NA))

siteB <- ggplot(data = world) + 
    geom_sf(fill = "antiquewhite1") +
    geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
    coord_sf(xlim = c(-80.3, -80), ylim = c(26.35, 26.65), expand = FALSE) +
    annotate("text", x = -80.23, y = 26.62, label= "Site B", size = 6) + 
    theme_void() +
    theme(panel.grid.major = element_line(colour = gray(0.5), linetype = "dashed", 
        size = 0.5), panel.background = element_rect(fill = "aliceblue"), 
        panel.border = element_rect(fill = NA))
```

DF with the coordinates of the 2 arrows:

```{r map-arrows-arrows}
arrowA <- data.frame(x1 = 18.5, x2 = 23, y1 = 9.5, y2 = 14.5)
arrowB <- data.frame(x1 = 18.5, x2 = 23, y1 = 8.5, y2 = 6.5)
```


```{r map-arrows-plot, fig.width = 10, fig.height = 7, out.width = "90%"}
ggplot() +
    coord_equal(xlim = c(0, 28), ylim = c(0, 20), expand = FALSE) +
    annotation_custom(ggplotGrob(florida), xmin = 0, xmax = 20, ymin = 0, ymax = 20) +
    annotation_custom(ggplotGrob(siteA), xmin = 20, xmax = 28, ymin = 11.25, ymax = 19) +
    annotation_custom(ggplotGrob(siteB), xmin = 20, xmax = 28, ymin = 2.5, ymax = 10.25) +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowA, 
        arrow = arrow(), lineend = "round") +
    geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), data = arrowB, 
        arrow = arrow(), lineend = "round") +
    theme_void()
```


```{r, eval = FALSE}
ggsave("florida-sites.pdf", width = 10, height = 7)
```



```{r listplots_function}

## list.plots <- list(rmarkplot, rmarkplot2, rmarkplot3)
## align_three_plots <- function(list.plots, family = "")
## {
##     require("dplyr")
##     gg <- ggplot()+
##         coord_equal(xlim = c(0, 80), ylim = c(0, 51), expand=TRUE) +
##         annotation_custom(ggplotGrob(rmarkplot), xmin = 0.0, xmax =57, ymin = 0.0, ymax = 50) +
##         annotation_custom(ggplotGrob(rmarkplot2),xmin = 58, xmax = 80, ymin = 25, ymax = 51) +
##         annotation_custom(ggplotGrob(rmarkplot3), xmin = 58, xmax = 80, ymin = 0.0, ymax = 29) +
##         labs(x = NULL, y = NULL) +
##         theme_void()

##     ## DF with the coordinates of the 2 arrows
##     df.arrows <- data.frame(id=1:2,
##         x=c(45.6,45.4),
##         y=c(21.7,19.8),
##         xend=c(58,58),
##         yend=c(35,12))
    
##     gg <- gg +
##         geom_segment(data = df.arrows %>% filter(id==1),
##             aes(x=x,y=y,xend=xend,yend=yend),
##             arrow = arrow(type="closed",length = unit(0.25,"cm"))) +
##         geom_segment(data = df.arrows %>% filter(id==2),
##             aes(x=x,y=y,xend=xend,yend=yend),
##             arrow = arrow(type="closed",length = unit(0.25,"cm")))
## }

```


## Creating a Simple Empty Square Plot

The next code will allow up to make a simple empty square plot, that can be cloned so we can place the maps inside. 


```{r listplot_blankplot}
## p <- ggplot() +
##   theme_map() +
##   theme(panel.border = element_rect(color = "black", size = 0.5, fill = NA),aspect.ratio = 1)

```

## Cloning and Final Map 

The function `mget` will clone the square plots three times. The `three` is just to combinge the `align_three_plots` function and the repetition plots in one argument. And the final step is to plot the function and the plots together. 

```{r listplot_finalplot}
## plots <- mget(rep("p", 3))

## three <- align_three_plots(plots)

## plot(three)
```







# Maps an legend placement

The map created below will have a legend placed in the center. First a legend must be create. The map itself with the legend, doesn't have to be accurate, but the legend must be. 

```{r legendmap}
LegendMap <- ggplot(data = world) +
  geom_sf(aes(fill=REGION)) +
  scale_fill_viridis_d(option="plasma")
```

```{r legendmap_maps, include=FALSE}
Map1 <- ggplot(data = world) +
  geom_sf(aes(fill=REGION)) +
  coord_sf(xlim = c(-10.00, 40.00), ylim = c(20.00, 50.00), expand=TRUE) +
  scale_fill_viridis_d(option="plasma") +
  guides(fill=guide_legend(show=FALSE)) +
  theme_map() +
  theme(legend.position= "none", panel.grid.major = element_line(colour = "azure", linetype = "dashed", size = 0.5), panel.background = element_rect(fill = "azure"), panel.border=element_rect(fill=NA),plot.title = element_text(size=16, face="bold"))

Map2 <- ggplot(data = world) +
  geom_sf(aes(fill=REGION)) +
  coord_sf(xlim = c(-100.00,-60.00 ), ylim = c(20.00, 50.00), expand=TRUE) +
  scale_fill_viridis_d(option="plasma") +
  guides(fill=guide_legend(show=FALSE)) +
  theme_map() +
  theme(legend.position= "none", panel.grid.major = element_line(colour = "azure", linetype = "dashed", size = 0.5), panel.background = element_rect(fill = "azure"), panel.border=element_rect(fill=NA),plot.title = element_text(size=16, face="bold"))

```

The function `get_legend`, will grab any legend from any `ggplot` map, or graph. In the function `plot_grid`, the maps that were created,  Map1 and Map2, will be plotted with their associated themes. In this case there is no theme or position, but the option is available. The command `rel_widths`, will specify the size of each pane of the `plot_grid`. The legend will be placed in the middle, and requires the largest size. 


```{r legendmap_prow}

library("cowplot")
legend <- get_legend(LegendMap+ theme(legend.position="left") )


prow <- plot_grid( Map1 + theme(legend.position="none"), 
                   NULL, Map2 + theme(legend.position="none"),
                   nrow = 1,
                   rel_widths = c(1, 1.5, 1)
)

```

The final map will have the legend "grobbed" and added to the `prow` plot. The first argument is the `legend`, that was taken previously with `get_legend`, and after the first set of restrictions are the left position, the height, and the right position. The positions might have to be tested a few times to check on how accurate the placement is. 

```{r legendmap_final}
prow + draw_grob(legend, 2/4,0/8, 0.003) 
```
